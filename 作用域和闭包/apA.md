我们在第二章节讨论了动态作用域，并和词法作用域做了比较。大部分其他语言包括javascript都是应用了词法作用域。

我们将简要地分析一下动态作用域，以便更加深入地理解两者之间的区别。事实上，动态作用域就像javascript另一个重要机制 ```this``` 的表亲。我们会在这本书的"*this & Object Prototypes* "章节仔细介绍 ```this```。

从第二章节可以得出，词法作用域建立了引擎如何查询变量和位置关系的规则。它重要特征是在它是在代码书写阶段被定义的。（假设你没有用 ```eval()``` 和 ``` with``` 进行'欺骗'。 ）

动态作用域意味着作用域范围不是在声明后保持不变，而是运行时动态变化。我们可以通过代码说明这一点。
```
function foo() {
	console.log( a ); // 2
}

function bar() {
	var a = 3;
	foo();
}

var a = 2;

bar();
```
  词法作用域会根据RHS方式在 ```foo()``` 作用域内查询变量 ```a``` ,没有找到，然后顺着作用域链到全局作用域链中查找，最终输出 ```2``` 。
  
  相比较而言，动态作用域不会在意方法和作用域是如何以及在哪里被声明，而是他们从何处被调用。换一句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。
  
  所以，如果javascript有动态作用域，运行  ```foo()``` ，理论上下方的代码的输出结果应该是3。
```
function foo() {
	console.log( a ); // 3  (not 2!)
}

function bar() {
	var a = 3;
	foo();
}

var a = 2;

bar();
```
怎么会这样呢？原来，当 没有在 ```foo()``` 的作用域内找到变量 ```a``` ，动态作用域不会根据（词法）作用域逐级向上查找，而是查找代码调用的位置。既然是```bar ```调用了``` foo()```,就在 ```bar()``` 的作用域内查找，获得变量 ```a```,输出结果3。

很奇怪吗？你现在可以会这么觉得。

这可能是因为你工作中使用的（或深层理解的）只是词法作用域，所以动态作用域相对陌生。如果用动态作用域开发过，可能理解起来更自然，词法作用域只是odd-ball(注解1)。

事实上，**javascript没有动态作用域**。它只有词法作用域，干净利落。但是 ```this``` 机制和动态作用域颇为相像。

两者的不同之处是，**词法作用域是在代码书写阶段确定的，而动态作用域（this!）是运行阶段确定的**。词法作用域关心函数在何处被声明，而动态作用域关心函数何处被调用。

最后，```this``` 的作用域块和动态作用域相似，也由函数被调用的位置所决定。如果想更深入了解 ```this``` 可以阅读*"this & Object Prototypes"* 章节。


----------


>注解（1）：经典Oddball范式为在一项实验中,随机呈现作用于同一感觉通道的两种刺激,刺激出现的概率有很大差别.概率大者我们称之为标准刺激(standard stimuli),相当于是整个实验中的背景;概率小和偶然出现的刺激则为偏差刺激(deviant stimuli).因二者物理属性相差很小,偏差刺激如同经常出现的标准刺激发生了偏差,故"标准刺激"与"偏差刺激"因此得名.经典Oddball范式中,偏差刺激出现的概率应通常为20%左右;标准刺激出现的概率通常为80%左右.