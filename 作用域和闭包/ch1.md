你不知道的JS：作用域和闭包
=====
第一章：什么是作用域
---
在几乎所有编程语言中，储存值到变量中和稍后检索或改变这些值都是最基本的能力之一。事实上，这种存储值到变量和将值移除变量的能力给出了程序的状态。

没了这个概念的话，一个程序也能完成一些任务，但他们就会有很多地方被限制并且一点都不有趣了。

但是把变量包含到我们的程序中带来的最有趣的问题是：这些变量在哪儿？或者说，他们存储在哪儿？最重要的是，当我们的程序需要这些变量的时候，它是如何找到他们的？

这些问题需要一个定义明确的规则，用于存储变量在某些位置，以及在之后再找出这些变量，我们可以把这个规则叫：作用域。

但是，作用域规则在哪儿设置？应该怎么设置?

## 编译原理

这可能是不言而喻的，或者可能令人惊讶——取决于你融会贯通各种语言的能力，但是尽管JS属于一般范畴的动态型和解释型语言，实际上它却是一个编译型语言。它不是提前编译好的，因为有许多传统编译语言也不是各种分布式编译系统的产物。

但是，尽管如此，JS引擎也执行着许多相同的步骤，尽管它使用的是一种更为复杂的方式——比我们可能意识到的任何传统编译语言。

在传统的编译语言过程中，一块源代码，也就是你的程序，会在执行前遵从典型的‘三步走’，也就是‘编译’：

1. 分词/词法分析：分词指将一段字符串破成有意义的（相对于这门语言）小块。比如，考虑这段代码：var a=2;这条程序可能会被破成下面的部分：var , a, =,2,还有；  空白可能成为分词小块也可能不会，这得取决于它是否有含义。

    **注**：分词和词法分析之间的区别既微妙又学术，但关键在于这些小块被明确为有状态的还是无状态的。简单点儿说，如果分词块儿调用的是有状态的词法分析规则，来区分a应该作为一个单独的词法块儿还是仅仅是另外一块词法块儿的一部分，那么这个过程就称作词法分析。（我的理解就是 把字符串分为有意义的tokens这是分词，确定每一小块代码段是应该独立还是应该和另外一块合并成一个token，这是词法分析）。

2. 解析：取一段分词过的代码流，然后把它变成一个代表了程序语法结构的嵌套元素树，这个树的名字叫AST(Abstract Syntax Tree)（抽象语法树)。

  在这个树状结构的解析中，对于var a=2;可能从最高层——变量声明（VariableDeclaration）开始，然后是它的子节点——标识符（Identifier）（它的值是a）,以及另外一个子节点AssignmentExpression的子节点叫NumericLiteral（它的值是2）。

3. 代码生成：这个过程是使用AST将代码块变为可执行的代码，这部分的过程很依赖于语言本身，包括它的目标平台等。
 
  所以为了避免在细节里太纠结，我们就直接说上述的AST处理了我们的var a = 2；并且把它变成了一行机器指令——这行指令创造出一个变量a，并且存了一个值进去。

 **注**：引擎如何管理系统资源这是一个很深的坑，超出了我们的讨论范围。所以我们只需要知道引擎可以按需求创造出变量并且给它赋值就可以了。

JS引擎做的工作远比这三步要复杂，比如，在解析和代码生成这两步的过程中，还有一定的步骤去以优化性能的执行，包括折叠冗余元素等。

所以，我们就言止于此好了，但是你很快就会意识到为什么我们需要关心这个，即使处于一个很高的水平，这些也是息息相关的。

还有一件事是js引擎并不像其他语言编译一样有充分的时间去优化，因为js编译并没有像其他语言一样发生在构造之前。

对于js来说，在许多情况下编译发生在执行这段代码前几微秒（或者更少！）的时间里，为了确保最快的性能，js引擎使用了各种技巧，这些都远远超出了我们讨论的“作用域”。

我们就这么说吧，为了简单起见，任何js代码都会在执行前被编译，所以，js编译器会拿走程序var a = 2，然后先编译它，然后准备去执行它。

## 理解作用域

我们学习作用域的方法就是根据一个会话来思考其处理的过程。但是，谁拥有这个会话呢？

### 演员

当我们把交互处理程序 var a = 2脑补成一些角色，他们有助于我们在后面理解会话：

 1. 引擎：负责编译和执行我们的JavaScript程序。
 2. 编译器:一个引擎的朋友，处理解析和代码生成的所有脏活累活（见上一节）。
 3. 作用域：引擎的另一个朋友，收集并维护所有声明的标识符（变量）的查找列表，并强制执行一组严格的规则，以了解当前执行代码的方式。

为了充分了解JavaScript的工作原理，您需要开始思考引擎（和朋友）的想法，提出问题，并回答这些问题。

## 来来回回

当你看到程序var a = 2时，你最有可能把它当作一个语句，但这不是我们的新朋友引擎看到的。事实上，引擎会看到两个不同的语句，一个是编译器在编译过程中处理的语句，另一个是在执行期间引擎处理的语句。

因此，我们来看看，引擎和他的小伙伴们将会怎么处理这段程序：var a = 2;

编译器将会做的第一件事就是执行词法将其分解成符号，这些符号接下来会被解析成一棵树。但是当编译器进行到代码生成的时候，他看待这个程序将和设想的有点不同。

这个程序的编译器会做的第一件事是完成词法分析将其分解成多个令牌,它会解析树。但当编译器代码生成,也许会对这个项目有所不同。

编译器实际上将会按下面的步骤处理

 1. 遇到var a，编译器要求作用域查看该特定范围集合的变量a是否已存在。 如果是这样，编译器忽略此声明并继续。 否则，编译器要求作用域为该范围集合声明一个名为a的新变量。
 
 2. 编译器接下来为引擎生成其随后要执行的代码，来处理 a = 2的赋值。引擎执行a = 2时，首先会询问作用域在当前作用域范围里面是否存在一个可以访问的变量 a 。如果有，引擎就会使用那个变量。如果没有，引擎就会在其他地方寻找。（见下面的嵌套范围部分）。
 
如果引擎最终找到一个变量，他将会把值 2 赋给它。否则，引擎会大叫出了一个错误！

总结来说：在进行赋值时，会产生两个截然不同的动作：首先，编译器在当前作用域范围里声明一个变量（如果先前没有声明），然后，当执行的时候，引擎在作用域中如果找到了这个变量，就给他赋值。

## 编译器有话说

为了进一步理解，我们需要了解更多一些的编译器术语。

当引擎执行编译器为第二步生成的代码的时候，它必须查找变量a，来看其是否已经被声明过，这个查找
在我们的例子中，据说引擎在查找变量a的时候，会执行一个LHS（lefthandside）查找。另一个查找的类型叫做RHS(righthand side)。

我敢打赌你可以猜测“L”和“R”是什么意思。 这些术语代表“左撇子”和“右撇子”。

边是什么？ **分配操作。**

换句话说，一个LHS查找会在一个变量出现在赋值运算符的左边时完成，一个RHS查找会在一个变量出现在赋值运算符的右边时完成。

实际上，更精确来说。为了我们的目的，RHS查找是不可区分的，只需简单地查看一些变量的值，而LHS查找则试图找到变量容器本身，以便它可以分配。

为了我们的目的，RHS查找是不可区分的，只需简单地查看一些变量的值，而LHS查找则试图找到变量容器本身，以便它可以分配。 这样，RHS本身并不意味着“任务的右侧”，更准确地说，它不是“左派”。

稍微微笑一会儿，你也可以认为“RHS”意味着“检索他/她的来源（价值）”，这意味着RHS意味着“去获得...的价值”。

让我们深入了解一下。

当我说：
```js
    console.log( a );

```
对 a 的引用就是一个RHS引用，因为这里没有什么赋值给 a 。相反的，我们在检索 a 的值，以便这个值可以传递给 console.log(...)。

相反的：
```js

    a = 2;
```
这里对 a 的引用就是一个LHS引用，因为我们实际上并不关心它当前的值是多少，我们只是想找到 a 这个变量，并将其作为 = 2 赋值操作的目标。

**注**：LHS和RHS意味着“任务的左/右侧”不一定意味着“=赋值运算符的左/右侧”。 还有其他几种分配方式发生，所以最好在概念上把它思考为：“谁是作业目标（LHS）”和“谁是作业来源（RHS）”。

考虑如下的程序，既有LHS也有RHS引用：
```js

    function foo(a) {
	console.log( a ); // 2 
	}
	
	foo( 2 );
```
上面最后一行作为函数调用foo(..)时，需要一次对foo的RHS引用，意思是，“去查找foo的值，并将它返回给我”。此外，(..)意思是foo的值应该被执行，因此它最好是一个函数。

这里有一个微妙但重要的任务。 **你发现了吗？**

你可能错过了隐含在这个代码片段中的a = 2。它发生在2作为一个参数传递给foo(..)函数的时候，在这种情况下，2被赋给了a。为了（隐式的）赋给参数a，此处执行了一次LHS查询。

这里也有一次对a的值的RHS引用，并且获得的结果传递给了console.log(..) console.log(..)需要一个引用来执行。对console对象也有一次RHS查询，然后会去判断是否有一个属性叫做log。

最后，我们可以概念化在传递2(通过变量a的RHS查找)到log(..)时有一个LHS/RHS交换。在log(..)的本地实现里面，我们可以假设它有参数，并且其第一个参数（可能叫做arg1）在将2赋值给他时，有一次LHS引用。

**注**：你可能会概念化函数声明函数foo(){…作为一个正常的变量声明和赋值,比如var foo(a)和foo =函数{ ....这样做,很容易认为这个函数声明涉及 LHS查找。

然而，微妙但重要的区别是编译器在代码生成期间处理声明和值定义，以便在引擎正在执行代码时，没有必要将功能值“赋值”给foo进行处理。 因此，我们在这里讨论的方式将函数声明视为LHS查找分配是不正确的。

## 引擎/作用域的会话
```js

    function foo(a) {
	console.log( a ); // 2
	}
	
	foo( 2 );
```
我们来将程序执行上面的代码段时进行的操作脑补成一段会话。他们的会话可能会是这样：

>***引擎***：嘿，作用域，我有一个对foo的RHS引用。你听说过它没？

>***作用域***：我听说过。编译器刚刚声明过它。它是一个函数，给你。

>***引擎***：帅气！好，我们来执行foo。

>***引擎***：嘿，作用域，我有一个对a的LHS引用，你听说过它没？

>***作用域***：是的，有。编译器之前声明它是一个foo的形参。给你。

>***引擎***：赞！多谢！现在将2赋值给a。

>***引擎***：嘿，作用域，不好意思再打扰一下。我有一个对console的RHS引用。听过他没？

>***作用域***：没问题，引擎哥，这是我该做的。是的，我听说过，他是内建的。给你。

>***引擎***：完美。查找log(..)，嗯。。它是一个函数。

>***引擎***：作用域哥，你可以帮我再看看a么，我有一个对它的RHS引用，虽然我记得它存在，但是我想再确认一下。

>***作用域***：没错，他在那呢，同样的值，没有改变。给你。

>***引擎***：酷毙了，将a的值2传递给log(..)

>...



## 测验

检查你的理解到目前为止。 确保播放引擎的一部分，并与作用域进行“对话”：
```js

    function foo(a) {
	var b = a;
	return a + b;
	}
	
	var c = foo( 2 );

```
 1. 识别所有的LHS查找（有3！）。
 
 2. 确定所有的RHS查找（有4！）。

**注**：查看测验答案的章节审查！

## 嵌套范围

我们说过作用域是一组通过标识符名字查找变量的规则。然后，通常情况下，不止一个作用域需要考虑。

就像一个函数块嵌套在另一个函数块里面一样，作用域也嵌套在其他作用域里面。因此，如果在直接的作用域中没有找到变量，引擎会查询下一个外层作用域，直到找到，或者达到最外层（即全局global）作用域。

考虑下面的例子：
```js

    function foo(a) {
	console.log( a + b );
	}
	var b = 2;
	
	foo( 2 ); // 4
```
对b的RHS引用无法在foo函数的内部解决，但是可以在其附近的作用域（（本例中为全局））得到解决。

因此，回到脑补的引擎和作用域的对话中，我们可以听到：

>***引擎***：嘿，函数foo的作用域，听过b么？我有一个对它的RHS引用。

>***作用域***：没，完全没听说过。继续奔跑吧，伙计。

>***引擎***：嘿，foo函数外面的那个作用域，原来你是全局作用域，你听说过b么？我有一个对它的RHS引用。

>***作用域***：是的，搁这儿呢，给你。


遍历嵌套作用域的简单规则就是：引擎从当前正在执行的作用域开始，查找这里的变量，如果没有找到，就继续往更高一级查找。如果达到了最外层的全局作用域，查找就会停止，不管有没有找到需要的变量。

## 基于隐喻

为了可视化嵌套的作用域分辨率的过程，我想让你想到这个高层建筑。

<img src="images/fig1.png"  width="500">

 该建筑代表我们的程序的嵌套范围规则集。 建筑物的一楼代表您目前正在执行的Scope，无论你身在何处。 该建筑的顶层是全球范围。

您可以通过查看当前楼层来解决LHS和RHS参考，如果没有找到，请将电梯带到下一层，查看那里，然后再下一步，等等。 一旦你到达顶层（全局范围），你可以找到你要找的东西，或者你没有找到。 但你不得不停止。

## 错误

无论我们称之为LHS还是RHS，是为什么呢？

因为当变量并没有被声明时（在任何作用域中都没找到），这两个查找的类型在此情况下表现得不同。

考虑如下情况：
```js
    function foo(a) {
	console.log( a + b );
	b = a;
	}
	foo( 2 );
```
当对b的第一次RHS查找时，并不会找到。这时它是一个"未声明"变量，因为在这个作用域中没有找到。

如果在嵌套作用域的任何地方，对变量进行RHS查找失败时，引擎会抛出一个ReferenceError。注意这里的错误类型是ReferenceError。

相反，如果引擎执行一个LHR查询，并且直到到达全局作用域的时候都没有找到这个变量，当程序没有在"Strict Model"下执行时，全局作用域会创建一个以其命名的变量，并且将其告诉引擎。

“不，以前没有一个，但我是有帮助的，为你创造了一个。”

在ES5中添加的“严格模式”[^ note-strictmode]与正常/轻松/懒惰模式有许多不同的行为。 一个这样的行为是它不允许自动/隐式的全局变量创建。 在这种情况下，将没有从LHS查找中返回的全局适用范围的变量，并且引擎会像RHS案例一样抛出ReferenceError。

现在，如果找到一个用于RHS查找的变量，但是您尝试使用不可能的值进行某些操作，例如尝试执行as-function的非函数值，或引用null或 未定义的值，然后引擎引发一种不同种类的错误，称为TypeError。

ReferenceError是作用域分辨率失败相关的，而TypeError意味着作用域分辨率是成功的，但是针对结果进行了非法/不可能的操作。

## 复习

作用域是一组决定何处以及如何查找一个变量的规则。这个查找可能是赋值给变量，即LHS(lefthand-side)引用，或者可能是为了检索其值，即RHS(righthand-side)引用。

LHS引用源自于赋值操作。作用域相关的赋值既可能发生在=运算符也可能发生在传递参数给函数。

JavaScript引擎在执行代码时会先编译，基于此，它将如var a = 2;这种语句分成两个独立的步骤：


 1. 首先，在当前作用域声明一个a。这会代码执行前执行。
 
 2. 随后，a = 2 查找变量a（LHS引用），如果找到就将2赋给它。



LHS和RHS引用都是在当前执行的作用域开始查找，并且如果需要的话，它们也会查找嵌套的作用域，一次一个作用域，直到到达全局作用域便会停止，不管有没有找到。

RHS失败时，会抛出ReferenceError
LHS失败时，会自动的，隐式的在全局创建以其命名的变量（非strict mode下），strict mode会抛出ReferenceError

### 测验答案
```js

    function foo(a) {
	var b = a;
	return a + b;
	}
	var c = foo( 2 );

```
 1. 确定所有的LHS查找（有3！）。
c = ..，a = 2（隐式参数赋值）和b = ..
 2. 确定所有的RHS查找（有4！）。
 foo(2.., = a;, a + .. and .. + b


[^ note-strictmode]：MDN：严格模式

