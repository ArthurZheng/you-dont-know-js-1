# 你不知道的JS: 作用域 & 闭包
# 第二章: 词法作用域
在第一章中，我们将"scope"定义为管理引擎如何通过变量的标识名查找它的规则集，或者在当前的*作用域*中，或者在它包含的任何一个*嵌套作用域*中查找到这个变量。

对于作用域如何工作这里有两个主要的模式。第一种目前是最为常见的，被大量变成语言所使用，它被称为**词法范围**，我们将深度研究它。仍然被一些语言使用的（如Bash脚本，Perl的某些模式）另外一种模式被称为**动态作用域**，

动态范围在附录A中有所介绍。我在这里只提及，仅提供与词法作用域的对比，这里是JavaScript使用的作用域模型。
## 词法阶段（Lex-time）

正如我们在第一章中讨论的，标准语言第一个传统阶段叫做lexing(aka, tokening)。如果你记得，词法过程检查一串源代码字符并通过一些状态的解析来为那些标记分配语义。

正是这个概念为理解词法作用域和名字的来源提供了基础。

有点循环的定义它，词法作用域是在词法阶段定义的作用域。换句话说，词法作用域是基于变量和块作用域被你写入的地点。因此，在你写入时，（大多数情况下）在词法处理器处理你的代码的时候，词法作用域已经被设置好了。

**注意：**我们将会看到一些方法来欺骗词法作用域，从而在词法分析器已经通过之后对它进行修改，但这些方法是不好的。将词法范围认为是词法唯一的，完全是作者本质上被认为是最佳实践。

我们来看看这个代码块
```js
function foo(a) {

	var b = a * 2;

	function bar(c) {
		console.log( a, b, c );
	}

	bar(b * 3);
}

foo( 2 ); // 2 4 12
```

这个代码示例中有三个嵌套的作用域。将这些范围视为彼此的气泡可能会有所帮助。
<img src="images/fig2.png" width="500">

**气泡 1**  涵盖了全局作用域，并且其中只有一个标识符`foo`。
**气泡 2** 涵盖的作用域`foo`，其中包含三个标识符： `a`, `bar` and `b`。
**气泡 3** 涵盖了作用域`bar`,只包含了一个标识符`c`。

作用域是由写入作用域的块来定义的，哪一个被嵌套在另一个里，等等。在下一章中，我们会讨论不同的单位作用域，但是现在，我们只是假设每个函数创造一个信息的作用域的气泡。
气泡`bar`完全包含在气泡`foo`中，是因为（而且只是因为）w我们选择定义函数`bar`的位置。

请注意这些嵌套的气泡是严格嵌套的。我们不是在讨论气泡可以跨界的维恩图。换句话说，函数的气泡是不能同时存在（部分）在两个外部范围的作用域气泡中，正如没有一个函数会部分地在两个父函数中的每一个内部。

### 查找
这些作用域气泡的结构和相对位置完全解释了*引擎*需要查找找到标识符的所有位置。

在上面的代码片段中，*引擎*执行的`console.log(..)(打印)`语句，并且寻找这三个引用的变量`console.log(..)`。它首先从最内层的范围开始--`bar`函数的作用域。它不会找到a那里，所以它上升一个级别，到最接近的作用域气泡中，就是`foo`函数中。它在那发现了a变量，因此它使用a变量。`b`也是一样，但是`c`,是在bar函数中找到的。

如果`c`同时存在`bar`函数和`foo`函数，`console.log(..)`语句会在`bar`函数中发现和使用，不会在`foo`函数中得到。

**一旦查找到第一个匹配值，作用域查找停止*。* 可以在多个嵌套作用域中指定相同的标识符名称，称为"覆盖"（最内层的标识符"覆盖"它外层的标识符）。无论覆盖如何，作用域查找总是从当时执行的最内层作用域开始查找，并且向外/向上运行直到第一次匹配才停止。

**注意:** 全局变量也自动是全局对象（像浏览器中的`window`等），所以它是可能去引用一个全局变量而不是它的词法名，但是相反间接地作为全局对象的属性引用。
```js
window.a
```

这种技术允许访问一个全局变量，否则这个变量由于被覆盖而无法访问。然而，非全局被覆盖的变量不能被访问。

不管这个函数从哪被调用，或者甚至它怎么被调用，它的词法作用域**仅**在这个函数被声明的时候。

词法作用域查找过程只使用一级标识符，比如`a`,`b`,`c`。如果你在一段代码中有一个引用变量`foo.bar.baz`，词法作用域适用于查找`foo`标识，到那时一旦它定位了这个变量，对象属性的访问规则会接替去分别解决`bar` and `baz` 属性。
## 欺骗词法

如果词法作用域仅在这个函数声明的时候定义，这完全是作者决定的，那么在运行的时候词法作用域怎么去被修改（欺骗）呢？

JavaScript有两个这样的机制。在更广泛的社区，他们都同样是不好，因为您的代码中使用的不良做法。但反对他们的典型论据往往缺少最重要的一点：**作弊词法作用域导致较差的性能**。
在我解释性能问题之前，我们来看看这两个机制是如何工作的。
### `eval`

eval(..)JavaScript中的函数使用一个字符串作为参数，并将该字符串的内容视为程序中该点实际上已经创作的代码。换句话说，您可以通过编程方式在您的创作代码中生成代码，并运行生成的代码，就像在编写一样。

评估eval(..)（双关）在这一点上，应该清楚如何eval(..)允许您通过欺骗和假装（也称为词法）在那一直写代码来修改词法范围作用域。

在eval(..)执行后的后续代码行中，引擎不会“知道”或“关心”上述代码被动态解释，从而修改了词法作用域环境。该引擎将只是简单履行其词法作用域查找，因为它总是这样。

请考虑以下代码：
```js
function foo(str, a) {
	eval( str ); // 欺骗!
	console.log( a, b );
}

var b = 2;

foo( "var b = 3;", 1 ); // 1 3
```
字符串"var b = 3;"被处理，在eval(..)调用时，作为一直存在的代码。因为该代码恰好声明一个新的变量b，它会修改现有的词法作用域foo(..)。实际上，如上所述，这段代码实际上是在外部（全局）范围内声明b的foo(..)覆盖变量b。

当console.log(..)调用时，它会发现a并b在作用域foo(..)内，并且找不到外部b。因此，我们打印出“1 3”而不是“1 2”，就像通常情况一样。

**注意：** 在这个例子中，为了简单起见，我们传入的“代码”字符串是一个固定的文字。但是可以通过根据程序的逻辑将字符添加到一起，可以方便地通过编程方式创建。eval(..)通常用于执行动态创建的代码，因为从字符串文字中动态评估本质上的静态代码将不会直接为编写代码提供真正的好处。

默认情况下，如果eval(..)执行的代码字符串包含一个或多个声明（变量或函数），则此操作会修改其eval(..)存在的现有词法作用域。从技术上讲，eval(..)可以通过各种各样的技巧（这里除了我们的讨论之外），间接地调用它，而是在全局作用域的上下文中执行，从而修改它。但是无论在哪种情况下，eval(..)都可以在运行时修改编写期间的词汇范围。

**注意:**  eval(..)在严格模式程序中使用时，它会在自己的词法作用域内运行，这意味着内部eval()的声明实际上不会修改封闭的作用域。
```js
function foo(str) {
   "use strict";
   eval( str );
   console.log( a ); // ReferenceError: a is not defined
}

foo( "var a = 2" );
```

JavaScript中还有其他的功能类似于eval(...)。
setTimeout(..)并且setInterval(..) 可以获取它们各自的第一参数的字符串，其内容被eval用作动态生成的函数的代码。这是旧的，遗留的，并且早已废弃的，不要这样做。

`new Function(..)`函数的构造类似地接收一个代码中字符串，它的**最后**一个参数变成动态生成的函数（第一个参数，如果有的话，是用于新函数命名的参数）。这个函数构造函数的语法稍微比安全eval(..)，但是在代码中仍然应该避免这种情况。

在程序内部动态生成代码的用例非常罕见，因为性能下降几乎不值得。


### `with`


另一个在JavaScript中不好的（现在已经弃用！）的功能是欺骗词法作用域的with关键词。有多种有效的方法可以说明with，但是我将从这里选择它如何交互和影响词法作用域的角度来说。

`with`通常将其解释为简单方便地针对对象进行多个属性引用，而不必每次重复对象引用。
例如:

```js
var obj = {
	a: 1,
	b: 2,
	c: 3
};

// 多次烦人的去重复obj
obj.a = 2;
obj.b = 3;
obj.c = 4;

// 更简单实用，引用一次obj
with (obj) {
	a = 3;
	b = 4;
	c = 5;
}
```

然而，在这里还有更多的事情，而不仅仅是方便简单的对象属性访问。思考：
```js
function foo(obj) {
	with (obj) {
		a = 2;
	}
}

var o1 = {
	a: 3
};

var o2 = {
	b: 3
};

foo( o1 );
console.log( o1.a ); // 2

foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2 -- 哎呀，全局泄露
```

在此代码示例，两个对象o1和o2被创建。一个有`a`属性，另一个没有。foo(..)函数将对象引用obj作为参数，并调用with (obj) { .. }引用。在with块内，我们使一个变量a看起来可能是是一个正常的词法引用，实际上是一个LHS（赋值运算）引用，为它赋值2。

当我们传入`o1`时，a = 2赋值找到该属性o1.a并赋予其值2，如后续语句所反映的console.log(o1.a)那样。然而，当我们传入时o2，由于它没有a属性，所以不会创建这样的属性，并o2.a保留undefined。

但是，我们注意到一个特殊的副作用，即全局变量a是由赋值a = 2创建的。怎么会这样呢？

with声明使用了一个具有零个或多个属性对象的，**该对象仿佛对待它好像是一个完全独立的词法作用域**，从而该对象的属性被视为在“作用域”词法上定义的标识符。

**注意：** 即使一个with块把对象当做词法作用域一样，在with块内的一var声明也不会被限制到该with块，而是包含函数作用域。

虽然该eval(..)函数可以修改现有的词法作用域，如果它使用一个或多个声明的代码字符串，该with语句实际上会从传递给它的对象创建一个全新的词汇范围。

以这种方式理解，当我们传o1时，“作用域”中具有与该o1.a属性对应的“标识符”。但是当我们用o2作为“作用域”时，它没有这样的a“标识符”，所以出现了LHS标识符查找的正常规则（见第1章）。

无论是“作用域”o2，或者作用域foo(..)，甚至全局作用域，有一个被发现的a标识符，所以当a = 2被执行时，其导致自动全局被创建（因为我们在非严格模式） 。

with在运行时将一个对象及其属性转换成具有 “标识符” 的“作用域” ，这是一种奇怪的想法。但这是我能看到的结果所能给出的最清楚的解释。
.
注：除了是一个去使用的坏主意，无论是eval(..)和with受严格模式影响（限制）。with绝对不允许，而不允许各种形式的间接或不安全eval(..)，同时保留核心功能。
### 性能
eval(..)和with除了在编写时定义作用域，只能通过在运行时修改或创建新的词法作用域。

那么，有什么大不了的，你说？如果他们提供更复杂的功能和编码灵活性，这些功能不是很好吗？没有。

JavaScript 引擎在编译阶段执行了许多性能优化。其中一些归结为能够基本上静态地分析代码，并预先确定所有变量和函数声明的位置，以便在执行期间解决标识符花费的功夫较少。

但是如果引擎在代码中找到eval(..)或者with，它本质上必须假设所有它对标识符位置的认知都可能是无效的，因为它不能在词法时间内知道你可以传递哪些代码eval(..)来修改词法作用域，或哪些内容您可传能递给您的对象with来创建要查询的新的词法作用域。

换句话说，悲观的说如果eval(..)还是with存在的，大多数这些优化它会做毫无意义，所以它根本一点不进行优化。

您的代码几乎肯定会倾向于由事实较慢只需运行，包括eval(..)或with代码的任何位置。无论引擎如何巧妙地限制这些悲观假设的副作用，**无论如何，如果没有优化，代码运行速度就会变慢**。
## 总结

词法作用域意味着作用域由函数在哪里声明的的编写时间决定的。汇编的词法阶段基本上能够知道所有标识符在何处以及如何被声明，从而预测在执行过程中如何查找它们。

JavaScript中的两个机制可以“欺骗”词法作用域：eval(..)和with。前者可以通过评估一个具有一个或多个声明的“代码”字符串来修改现有的词法作用域（在运行时）。后者通过将对象引用视为 “u”，将对象的属性视为作用域标识符，实质上创建了一个全新的词法范围（再次，在运行时）。

这些机制的缺点在于它破坏了Engine对范围查找执行编译时优化的能力，因为Engine必须悲观地假设这种优化将无效。代码将运行与使用任何功能的结果要慢。
**不要使用它们.**